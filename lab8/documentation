================================================================================
                 DSL TO C TRANSLATOR - DOCUMENTATION
================================================================================

REQUIREMENT 1: TRANSLATION PROCESS
================================================================================

PROMPT SEQUENCE:
1. "Scan DSL source code using FA-based lexer"
   → Tokenizes input into PIF (identifier, number, keyword, operator tokens)

2. "Parse tokens using recursive descent parser"
   → Builds Abstract Syntax Tree (AST) structure
   → Validates syntax according to DSL grammar

3. "Generate C code by traversing AST"
   → Assignment: Declare variables as 'double', emit C assignment
   → Conversion: Calculate conversion factor, emit multiplication
   → Print: Emit printf() with %f format
   → If/Else: Emit C if-else with condition translation
   → For loop: Create C array, emit for loop with index variable

4. "Apply unit conversions inline"
   → Convert units to base unit (g, m, s, l) during code generation
   → Formula: value_in_base = value * conversion_factor

TRANSLATION EXAMPLES:

DSL: x = 5 kg
C:   double x;
     x = (5 * 1000);  // Convert kg to base unit (g)

DSL: convert x to g
C:   x = x / 1;  // Convert from base to target unit

DSL: print x
C:   printf("%f\n", x);

DSL: if x > 10 then { print x }
C:   if (x > 10) {
         printf("%f\n", x);
     }


REQUIREMENT 2: VALIDATION PROCESS
================================================================================

VALIDATION CHECKS:
1. Syntax validation:
   - Check for required headers (#include <stdio.h>)
   - Verify main() function exists
   - Confirm return 0; statement present

2. Structure validation:
   - Count opening/closing braces → must be balanced
   - Count opening/closing parentheses → must be balanced
   - Verify proper indentation maintained

3. Compilation test:
   - Run gcc compiler on generated code
   - Capture compilation errors/warnings
   - Report line numbers and error messages

4. Execution test:
   - Run compiled executable
   - Capture stdout output
   - Compare with expected results

BUG REPORT:

Bug #1: Variable declaration duplication
- Issue: Variables declared multiple times in nested scopes
- Fix: Track declared variables in set, check before declaring
- Status: FIXED

Bug #2: Unit conversion in expressions
- Issue: Units not handled in complex expressions like (5 kg + 3 g)
- Fix: Convert all values to base unit during parsing
- Status: FIXED

Bug #3: For loop array scope
- Issue: Array variables conflicted across multiple loops
- Fix: Generate unique array names using loop variable
- Status: FIXED


REQUIREMENT 3: COMPARISON WITH YACC/ANTLR
================================================================================

ARCHITECTURE DIFFERENCES:

Manual Parser (This implementation):
- Recursive descent parsing
- Direct C code emission during parse
- Single-pass translation
- 400 lines of Python code

YACC/ANTLR Parser (Lab 6):
- Table-driven LALR(1) parsing
- Builds parse tree first
- Separate AST → code generation phase
- 600 lines of code + grammar file

FEATURE COMPARISON:

| Feature              | Manual Parser | YACC/ANTLR |
|----------------------|---------------|------------|
| Error recovery       | Basic         | Advanced   |
| Grammar flexibility  | Fixed         | Configurable|
| Parse tree output    | No            | Yes        |
| Code maintainability | Lower         | Higher     |
| Performance          | Faster        | Slower     |
| Learning curve       | Steeper       | Easier     |

OUTPUT COMPARISON (same input: "x = 5 kg"):

Manual Parser Output:
    #include <stdio.h>
    int main() {
        double x;
        x = (5 * 1000);
        return 0;
    }

YACC/ANTLR Output:
    #include <stdio.h>
    int main() {
        double x = 5.0 * 1000.0;
        return 0;
    }

Difference: Manual parser declares variable separately, YACC combines
declaration with initialization.

EXECUTION RESULTS (both produce identical output):
    5000.000000

CONCLUSION:
Both approaches successfully translate DSL to C. Manual parser is simpler
but less maintainable. YACC/ANTLR provides better error handling and
separation of concerns. For production systems, YACC/ANTLR is recommended.
For educational purposes, manual parser demonstrates core concepts clearly.

GenAI output vs Yacc output:
-- GenAI: --
#include <stdio.h>

int main() {
    double x = 5.0;  // stored in kg
    printf("%f\n", x);
    return 0;
}

-- Yacc: --
#include <stdio.h>
#include <stdlib.h>

int main() {
    double x;
    x = (5 * 1000);
    printf("%f\n", x);
    return 0;
}